<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Track your crypto, stocks, and gold portfolio with real-time prices">
  <title>Portfolio Tracker | Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" href="images/icon-192.png">
  <link rel="apple-touch-icon" href="images/icon-192.png">
  <meta name="theme-color" content="#0f172a">
  <style>
    .profit {
      color: #00d4aa;
    }

    .loss {
      color: #ff5050;
    }

    .profit-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .profit-badge.positive {
      background: rgba(0, 212, 170, 0.15);
      color: #00d4aa;
    }

    .profit-badge.negative {
      background: rgba(255, 80, 80, 0.15);
      color: #ff5050;
    }

    .asset-icon-img {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      object-fit: cover;
      flex-shrink: 0;
    }

    .total-profit {
      text-align: center;
      margin-top: var(--spacing-sm);
      padding-top: var(--spacing-sm);
      border-top: 1px solid var(--border-color);
    }

    .total-profit-label {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .total-profit-value {
      font-size: 1.1rem;
      font-weight: 600;
    }

    /* Mobile-optimized asset item */
    .asset-item {
      flex-wrap: wrap;
    }

    .asset-value {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
      min-width: 0;
    }

    .asset-pnl {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    /* Mobile responsive */
    @media (max-width: 480px) {
      .asset-item {
        flex-direction: row;
        align-items: center;
        gap: 0;
      }

      .asset-value {
        width: auto;
        align-items: flex-end;
        padding-left: 0;
      }

      .asset-pnl {
        justify-content: flex-end;
      }

      .stat-card {
        padding: var(--spacing-sm);
      }

      .stat-value {
        font-size: 1.2rem;
      }

      .chart-wrapper {
        width: 260px;
        height: 260px;
      }

      .chart-total-value {
        font-size: 1.4rem;
      }
    }

    /* Mobile Mode Toggle */
    .mobile-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--text-muted);
      cursor: pointer;
      user-select: none;
    }

    .mobile-toggle input {
      width: 14px;
      height: 14px;
      cursor: pointer;
      accent-color: var(--accent-crypto);
    }

    .mobile-toggle:hover {
      color: var(--text-primary);
    }

    /* Mobile Mode Layout - only applies when checkbox is checked */
    body.mobile-mode main {
      display: flex;
      flex-direction: column;
    }

    body.mobile-mode .dashboard-grid {
      display: contents;
      /* Unwrap the grid so children can be reordered */
    }

    body.mobile-mode #chartSection {
      order: 1;
    }

    body.mobile-mode #statsGrid {
      order: 2;
    }

    body.mobile-mode #assetsSection {
      order: 3;
    }

    /* Chart Data Badge */
    .chart-data-badge {
      display: inline-block;
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 12px;
      margin-left: 8px;
      font-weight: 500;
      vertical-align: middle;
    }

    .chart-data-badge.real {
      background: rgba(0, 212, 170, 0.15);
      color: #00d4aa;
      border: 1px solid rgba(0, 212, 170, 0.3);
    }

    .chart-data-badge.estimated {
      background: rgba(255, 179, 0, 0.15);
      color: #ffb300;
      border: 1px solid rgba(255, 179, 0, 0.3);
    }

    /* Pull to Refresh */
    .refresh-loader {
      position: fixed;
      top: -60px;
      left: 0;
      width: 100%;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
      pointer-events: none;
    }

    .refresh-spinner {
      width: 24px;
      height: 24px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-top-color: var(--accent-crypto);
      border-radius: 50%;
      opacity: 0;
      transform: scale(0.8);
      transition: opacity 0.2s, transform 0.2s;
    }

    .refresh-spinner.spinning {
      animation: spin 0.8s linear infinite;
    }

    .refresh-loader.visible .refresh-spinner {
      opacity: 1;
      transform: scale(1) rotate(0deg);
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <!-- Pull to Refresh Loader -->
  <div class="refresh-loader" id="refreshLoader">
    <div class="refresh-spinner" id="refreshSpinner"></div>
  </div>

  <!-- Fixed Mobile Toggle -->
  <div class="fixed-mobile-toggle" id="fixedMobileToggle">
    <label title="Toggle Mobile Mode">
      <input type="checkbox" id="mobileMode">
      <span class="toggle-icon">üì±</span>
    </label>
  </div>

  <!-- Mobile Header Bar -->
  <div class="mobile-header-bar">
    <div class="mobile-header-title">
      <img src="images/icon-192.png" alt="Logo" style="width: 28px; height: 28px; border-radius: 6px;">
      Portfolio
    </div>
    <div class="mobile-header-actions">

      <button id="mobileThemeBtn" class="mobile-header-btn" title="Theme">üåô</button>
    </div>
  </div>

  <div class="container">
    <!-- Header -->
    <header class="header">
      <div class="logo">
        <img src="images/icon-192.png" alt="Logo" style="width: 32px; height: 32px; border-radius: 6px;">
        Portfolio Tracker
      </div>
      <nav style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <!-- Refresh Button -->

        <!-- Currency Selector -->
        <select id="currencySelect" class="currency-select" title="Select currency">
          <option value="USD">üá∫üá∏ USD</option>
          <option value="VND">üáªüá≥ VND</option>
        </select>
        <!-- Theme Toggle -->
        <button id="themeToggle" class="theme-toggle" title="Toggle theme">
          <span id="themeIcon">üåô</span>
        </button>
        <a href="rebalance.html" class="nav-link">‚öñÔ∏è Rebalance</a>
        <a href="admin.html" class="nav-link">‚öôÔ∏è Manage</a>
      </nav>
    </header>

    <!-- Main Dashboard -->
    <main>
      <!-- Mobile Hero Section (Redesigned) -->
      <div class="hero-section" id="heroSection">
        <div class="mobile-hero-top">
          <div class="mobile-hero-main">
            <div class="mobile-hero-label">Total Balance</div>
            <div class="mobile-hero-value" id="heroTotalValue">$0</div>
            <div id="heroScrubDate"
              style="display: none; color: var(--text-secondary); font-size: 14px; margin-bottom: 4px;"></div>
            <div class="mobile-hero-pnl" id="heroPnlContainer">
              <span class="mobile-pnl-amount" id="heroPnlAmount">$0</span>
              <span class="mobile-pnl-badge positive" id="heroPnlBadge">
                <span id="heroPnlPercent">+0%</span>
              </span>
            </div>
          </div>

        </div>
        <div class="mobile-hero-chart">
          <canvas id="heroMiniChart"></canvas>
          <div id="mobileChartLoading" class="mobile-chart-loading" style="display: none;">
            <span class="loading-dots">Loading</span>
          </div>
        </div>
        <div class="mobile-timeframe-selector">
          <button class="timeframe-btn active" onclick="updateHistoryChart(1)">24H</button>
          <button class="timeframe-btn" onclick="updateHistoryChart(7)">1W</button>
          <button class="timeframe-btn" onclick="updateHistoryChart(30)">1M</button>
          <button class="timeframe-btn" onclick="updateHistoryChart(90)">3M</button>
          <button class="timeframe-btn" onclick="updateHistoryChart(180)">6M</button>
          <button class="timeframe-btn" onclick="updateHistoryChart(365)">1Y</button>
          <button class="timeframe-btn" onclick="updateHistoryChart(0)">ALL</button>
        </div>
        <!-- Category Pills -->
        <div class="mobile-category-pills" id="categoryPills">
          <div class="category-pill" data-category="crypto">
            <div class="category-pill-icon crypto">‚Çø</div>
            <div class="category-pill-info">
              <span class="category-pill-label">Crypto</span>
              <span class="category-pill-value" id="pillCryptoValue">$0</span>
            </div>
          </div>
          <div class="category-pill" data-category="stocks">
            <div class="category-pill-icon stocks">üìà</div>
            <div class="category-pill-info">
              <span class="category-pill-label">Stocks</span>
              <span class="category-pill-value" id="pillStocksValue">$0</span>
            </div>
          </div>
          <div class="category-pill" data-category="gold">
            <div class="category-pill-icon gold">ü•á</div>
            <div class="category-pill-info">
              <span class="category-pill-label">Gold</span>
              <span class="category-pill-value" id="pillGoldValue">$0</span>
            </div>
          </div>
        </div>
      </div>



      <!-- Stats Overview (Desktop Only) -->
      <div class="stats-grid fade-in" id="statsGrid">
        <div class="stat-card crypto">
          <div class="stat-label">Crypto</div>
          <div class="stat-value" id="cryptoValue">$0</div>
          <div class="stat-percent" id="cryptoPercent">0%</div>
          <div class="stat-profit" id="cryptoProfit"></div>
        </div>
        <div class="stat-card stocks">
          <div class="stat-label">USA Stocks</div>
          <div class="stat-value" id="stocksValue">$0</div>
          <div class="stat-percent" id="stocksPercent">0%</div>
          <div class="stat-profit" id="stocksProfit"></div>
        </div>
        <div class="stat-card gold">
          <div class="stat-label">Gold</div>
          <div class="stat-value" id="goldValue">$0</div>
          <div class="stat-percent" id="goldPercent">0%</div>
          <div class="stat-profit" id="goldProfit"></div>
        </div>
      </div>

      <!-- Chart and Assets Grid -->
      <div class="dashboard-grid">
        <!-- Chart Section (Left) -->
        <div class="card fade-in" id="chartSection">
          <div class="card-title">Portfolio Allocation</div>
          <div class="chart-container">
            <div class="chart-wrapper">
              <canvas id="portfolioChart"></canvas>
              <div class="chart-center">
                <div class="chart-total-label">Total Balance</div>
                <div class="chart-total-value" id="totalValue">$0.00</div>
              </div>
            </div>
          </div>
          <!-- Total Profit/Loss -->
          <div class="total-profit" id="totalProfitContainer" style="display: none;">
            <div class="total-profit-label">Total P/L</div>
            <div class="total-profit-value" id="totalProfitValue">$0</div>
          </div>
          <div class="legend">
            <div class="legend-item" data-category="crypto">
              <span class="legend-color crypto"></span>
              <span class="legend-label">Crypto</span>
            </div>
            <div class="legend-item" data-category="stocks">
              <span class="legend-color stocks"></span>
              <span class="legend-label">Stocks</span>
            </div>
            <div class="legend-item" data-category="gold">
              <span class="legend-color gold"></span>
              <span class="legend-label">Gold</span>
            </div>
          </div>

          <!-- Enhanced Performance Chart Section -->
          <div class="performance-chart-container" id="performanceSection">
            <div class="performance-header">
              <div>
                <div class="performance-title">
                  Performance <span id="chartDataBadge" class="chart-data-badge" style="display: none;"></span>
                </div>
                <div class="performance-value" id="perfCurrentValue">$0</div>
                <div id="perfScrubDate"
                  style="font-size: 0.9rem; color: var(--text-muted); margin-top: 4px; display: none;"></div>
              </div>
              <div class="performance-change positive" id="perfChange">
                <span id="perfChangeIcon">‚Üë</span>
                <span id="perfChangeValue">+0%</span>
              </div>
            </div>

            <div class="period-selector" style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
              <button class="period-btn active" data-days="1" onclick="updateHistoryChart(1)">24H</button>
              <button class="period-btn" data-days="7" onclick="updateHistoryChart(7)">1W</button>
              <button class="period-btn" data-days="30" onclick="updateHistoryChart(30)">1M</button>
              <button class="period-btn" data-days="90" onclick="updateHistoryChart(90)">3M</button>
              <button class="period-btn" data-days="180" onclick="updateHistoryChart(180)">6M</button>
              <button class="period-btn" data-days="365" onclick="updateHistoryChart(365)">1Y</button>
              <button class="period-btn" data-days="0" onclick="updateHistoryChart(0)">ALL</button>
            </div>

            <div class="performance-chart-wrapper">
              <canvas id="historyChart"></canvas>
              <div class="chart-tooltip-floating" id="chartTooltipFloating">
                <div class="chart-tooltip-date"></div>
                <div class="chart-tooltip-value"></div>
              </div>
            </div>

            <div id="historyEmpty" style="display: none; text-align: center; padding: 40px; color: var(--text-muted);">
              <div style="font-size: 2rem; margin-bottom: 8px;">üìä</div>
              <div>Not enough data yet</div>
              <div style="font-size: 0.8rem; margin-top: 4px;">Check back tomorrow!</div>
            </div>

            <div class="chart-stats-row" id="chartStats">
              <div class="chart-stat">
                <div class="chart-stat-label">High</div>
                <div class="chart-stat-value" id="statHigh">-</div>
              </div>
              <div class="chart-stat">
                <div class="chart-stat-label">Low</div>
                <div class="chart-stat-value" id="statLow">-</div>
              </div>
              <div class="chart-stat">
                <div class="chart-stat-label">Avg</div>
                <div class="chart-stat-value" id="statAvg">-</div>
              </div>
              <div class="chart-stat">
                <div class="chart-stat-label">Change</div>
                <div class="chart-stat-value" id="statChange">-</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Assets List Card (Right) -->
        <div class="card fade-in" id="assetsSection">
          <div class="card-title" style="display: flex; justify-content: space-between; align-items: center;">
            Your Assets
            <div style="display: flex; align-items: center; gap: 12px;">
              <span id="portfolioPlainValue"
                style="font-size: 1rem; color: var(--text-secondary); font-weight: 500;">$0</span>
              <a href="admin.html" class="mobile-section-action">Manage ‚Üí</a>
            </div>
          </div>

          <!-- Assets Header Row (Mobile) -->
          <div class="assets-header"
            style="display: none; padding: 8px 16px; border-bottom: 1px solid var(--border-color); font-size: 0.8rem; color: var(--text-muted); text-transform: uppercase;">
            <div style="flex: 1.5; display: flex; align-items: center; gap: 4px;">
              <span>‚ñº</span> Qty. Total
            </div>
            <div style="flex: 1.2; text-align: right; padding-right: 12px;">Unrealized</div>
            <div style="flex: 0.8; text-align: right;">Price</div>
          </div>



          <div class="assets-list" id="assetsList">
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Tooltip -->
  <div class="chart-tooltip" id="chartTooltip"></div>

  <!-- Mobile Bottom Navigation -->
  <nav class="mobile-bottom-nav" id="mobileBottomNav">
    <div class="mobile-bottom-nav-inner">
      <button class="bottom-nav-item active" data-view="assets">
        <span class="bottom-nav-icon">üí∞</span>
        <span>Assets</span>
      </button>
      <button class="bottom-nav-item" data-view="chart">
        <span class="bottom-nav-icon">üìä</span>
        <span>Distribution</span>
      </button>

    </div>
  </nav>



  <!-- Scripts -->
  <script src="js/app.js"></script>
  <script src="js/dom-utils.js"></script>
  <script src="js/chart.js"></script>
  <script>
    // Dashboard Logic
    let chart;
    let isRefreshing = false;

    async function initDashboard() {
      // Initialize chart
      chart = new PortfolioChart('portfolioChart', 'chartTooltip');
      window.portfolioChart = chart;

      // Add legend click listeners
      document.querySelectorAll('.legend-item').forEach(item => {
        item.addEventListener('click', () => {
          const category = item.dataset.category;
          chart.showTooltipForCategory(category);
        });
      });

      // Load and display data
      await refreshData();
    }

    async function refreshData() {
      if (isRefreshing) return;

      const refreshBtn = document.getElementById('refreshBtn');
      const mobileRefreshBtn = document.getElementById('mobileRefreshBtn');
      isRefreshing = true;
      refreshBtn?.classList.add('spinning');
      mobileRefreshBtn?.classList.add('spinning');

      try {
        const data = await PortfolioApp.calculatePortfolio();
        window.lastPortfolioData = data; // Cache for UI restoration
        updateUI(data);
        chart.update(data);
      } catch (error) {
        console.error('Error refreshing data:', error);
      } finally {
        isRefreshing = false;
        refreshBtn?.classList.remove('spinning');
        mobileRefreshBtn?.classList.remove('spinning');
      }
    }

    function updateUI(data) {
      // Update total value - use compact format for large numbers
      const formattedTotal = PortfolioApp.formatCurrencyCompact(data.grandTotal);
      document.getElementById('totalValue').textContent = formattedTotal;

      // Update Hero Section (Mobile)
      document.getElementById('heroTotalValue').textContent = PortfolioApp.formatCurrency(data.grandTotal);

      // Update plain value next to "Your Assets" - full number format
      const plainValueEl = document.getElementById('portfolioPlainValue');
      if (plainValueEl) {
        plainValueEl.textContent = new Intl.NumberFormat('en-US', {
          style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0
        }).format(data.grandTotal);
      }

      // Update category stats (Desktop)
      const categories = ['crypto', 'stocks', 'gold'];
      categories.forEach(cat => {
        const catData = data.categories[cat];
        document.getElementById(`${cat}Value`).textContent =
          PortfolioApp.formatCurrency(catData.total);
        document.getElementById(`${cat}Percent`).textContent =
          PortfolioApp.formatPercent(catData.percentage);

        // Show profit/loss per category
        const profitEl = document.getElementById(`${cat}Profit`);
        if (catData.costBasis > 0) {
          const isPositive = catData.profitLoss >= 0;
          const sign = isPositive ? '+' : '';
          profitEl.innerHTML = `
            <span class="profit-badge ${isPositive ? 'positive' : 'negative'}">
              ${sign}${PortfolioApp.formatPercent(catData.profitLossPercent)}
            </span>
          `;
        } else {
          profitEl.innerHTML = '';
        }

        // Update mobile category pills
        const pillValue = document.getElementById(`pill${cat.charAt(0).toUpperCase() + cat.slice(1)}Value`);
        if (pillValue) {
          pillValue.textContent = PortfolioApp.formatCurrencyCompact(catData.total);
        }
      });

      // Update total profit/loss (Desktop)
      const profitContainer = document.getElementById('totalProfitContainer');
      const profitValue = document.getElementById('totalProfitValue');

      // Mobile Hero PnL elements
      const heroPnlContainer = document.getElementById('heroPnlContainer');
      const heroPnlBadge = document.getElementById('heroPnlBadge');
      const heroPnlAmount = document.getElementById('heroPnlAmount');
      const heroPnlPercent = document.getElementById('heroPnlPercent');

      if (data.totalCostBasis > 0) {
        const isPositive = data.totalProfitLoss >= 0;
        const sign = isPositive ? '+' : '';

        // Desktop
        if (profitContainer) {
          profitContainer.style.display = 'block';
          profitValue.className = `total-profit-value ${isPositive ? 'profit' : 'loss'}`;
          profitValue.textContent = `${sign}${PortfolioApp.formatCurrency(data.totalProfitLoss)} (${sign}${PortfolioApp.formatPercent(data.totalProfitLossPercent)})`;
        }

        // Mobile Hero
        if (heroPnlContainer) {
          heroPnlContainer.style.display = 'flex';
          heroPnlBadge.className = `mobile-pnl-badge ${isPositive ? 'positive' : 'negative'}`;
          heroPnlPercent.textContent = `${isPositive ? '‚Üë' : '‚Üì'} ${sign}${PortfolioApp.formatPercent(data.totalProfitLossPercent)}`;
          heroPnlAmount.textContent = `${sign}${PortfolioApp.formatCurrency(data.totalProfitLoss)}`;
          heroPnlAmount.className = `mobile-pnl-amount ${isPositive ? 'positive' : 'negative'}`;
        }
      } else {
        if (profitContainer) profitContainer.style.display = 'none';
        if (heroPnlContainer) heroPnlContainer.style.display = 'none';
      }

      // Update performance chart header (Desktop)
      const perfCurrentValue = document.getElementById('perfCurrentValue');
      if (perfCurrentValue) {
        perfCurrentValue.textContent = PortfolioApp.formatCurrency(data.grandTotal);
      }

      // Update assets list - Sort by Value Descending Globally
      const sortedAssets = [...data.assets].sort((a, b) => b.value - a.value);
      updateAssetsList(sortedAssets);
    }

    function updateAssetsList(assets) {
      const container = document.getElementById('assetsList');

      if (assets.length === 0) {
        DOMUtils.showEmptyState(container, 'No assets yet', {
          text: 'Add your first asset',
          href: 'admin.html'
        });
        return;
      }

      // Clear and render using safe DOM utils
      container.innerHTML = '';
      assets.forEach(asset => {
        const item = DOMUtils.createAssetItem(asset, {
          showValue: true,
          showPnL: true
        });
        container.appendChild(item);
      });
    }

    function getCategoryLabel(category) {
      const labels = {
        crypto: 'Crypto',
        stocks: 'Stocks',
        gold: 'Gold'
      };
      return labels[category] || category;
    }

    // Mobile Mode Toggle
    function initMobileMode() {
      const checkbox = document.getElementById('mobileMode');
      const saved = localStorage.getItem('portfolioMobileMode');

      const applyMobileMode = (isMobile) => {
        if (isMobile) {
          document.body.classList.add('mobile-mode');
          switchMobileView('assets');
        } else {
          document.body.classList.remove('mobile-mode');
          document.getElementById('chartSection').style.display = '';
          document.getElementById('assetsSection').style.display = '';
        }

        // Redraw charts after layout change
        setTimeout(() => {
          if (typeof chartData !== 'undefined' && chartData.length > 0) {
            drawMiniChart(chartData, 'heroMiniChart');
            drawEnhancedLineChart(chartData, 'historyChart');
          }
          if (window.portfolioChart) {
            window.portfolioChart.setupCanvas();
            window.portfolioChart.draw();
          }
        }, 50);
      };

      if (saved === 'true') {
        checkbox.checked = true;
        applyMobileMode(true);
      }

      checkbox.addEventListener('change', function () {
        applyMobileMode(this.checked);
        localStorage.setItem('portfolioMobileMode', this.checked);
      });
    }

    // Mobile View Switching (Bottom Nav)
    function switchMobileView(view) {
      if (!document.body.classList.contains('mobile-mode')) return;

      // Update bottom nav buttons
      document.querySelectorAll('.bottom-nav-item').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === view);
      });

      // Hide all sections
      const chartSection = document.getElementById('chartSection');
      const assetsSection = document.getElementById('assetsSection');
      const performanceSection = document.getElementById('performanceSection');
      const mobileAssetsHeader = document.getElementById('mobileAssetsHeader');

      chartSection.classList.remove('active-tab');
      assetsSection.style.display = 'none';
      if (mobileAssetsHeader) mobileAssetsHeader.style.display = 'none';

      // Show selected view
      switch (view) {
        case 'assets':
          assetsSection.style.display = 'block';
          chartSection.style.display = 'none'; // Explicitly hide chart
          if (mobileAssetsHeader) mobileAssetsHeader.style.display = 'flex';
          break;
        case 'chart':
          chartSection.classList.add('active-tab');
          chartSection.style.display = 'block';
          // Hide performance section in chart view
          if (performanceSection) performanceSection.style.display = 'none';

          // Trigger chart resize after display/visible
          setTimeout(() => {
            if (window.portfolioChart) {
              window.portfolioChart.setupCanvas();
              window.portfolioChart.draw();
            }
          }, 50);
          break;

      }
    }

    // Initialize Bottom Navigation
    function initBottomNav() {
      document.querySelectorAll('.bottom-nav-item[data-view]').forEach(btn => {
        btn.addEventListener('click', () => {
          const view = btn.dataset.view;
          if (view) switchMobileView(view);
        });
      });
    }

    // Tab System (legacy, kept for compatibility)
    function switchTab(tabId) {
      if (!document.body.classList.contains('mobile-mode')) return;
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabId);
      });
      document.getElementById('chartSection').classList.remove('active-tab');
      document.getElementById('assetsSection').classList.remove('active-tab');
      const target = document.getElementById(tabId);
      if (target) target.classList.add('active-tab');
    }

    function initTabSystem() {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
      });
    }

    // Event listeners


    // Mobile header buttons

    document.getElementById('mobileThemeBtn')?.addEventListener('click', () => {
      const newTheme = ThemeManager.toggle();
      document.getElementById('mobileThemeBtn').textContent = newTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
      document.getElementById('themeIcon').textContent = newTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    });

    // Theme Toggle
    document.getElementById('themeToggle').addEventListener('click', () => {
      const newTheme = ThemeManager.toggle();
      document.getElementById('themeIcon').textContent = newTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
      document.getElementById('mobileThemeBtn').textContent = newTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
      ToastManager.success(`Switched to ${newTheme} theme`);
    });

    // Currency Selector
    document.getElementById('currencySelect').addEventListener('change', async (e) => {
      await CurrencyManager.setCurrency(e.target.value);
      ToastManager.info(`Currency changed to ${e.target.value}`);
      refreshData();
    });

    // Pull to Refresh Logic
    function initPullToRefresh() {
      const loader = document.getElementById('refreshLoader');
      const spinner = document.getElementById('refreshSpinner');
      const main = document.querySelector('main');

      let startY = 0;
      let currentY = 0;
      let isPulling = false;
      let isRefreshing = false;

      const THRESHOLD = 80; // Pull distance to trigger refresh
      const MAX_PULL = 120; // Max visual pull distance

      document.body.addEventListener('touchstart', (e) => {
        // Only active in mobile mode and at top of page
        if (!document.body.classList.contains('mobile-mode') || window.scrollY > 0) return;

        // Prevent if touching a chart (to avoid conflict with scrubbing)
        if (e.target.tagName === 'CANVAS') return;

        startY = e.touches[0].clientY;
        isPulling = true;
        loader.style.transition = 'none'; // distinct types
      }, { passive: true });

      document.body.addEventListener('touchmove', (e) => {
        if (!isPulling || isRefreshing) return;

        const y = e.touches[0].clientY;
        const delta = y - startY;

        // Only handle pull down when at top
        if (delta > 0 && window.scrollY <= 0) {
          // Add resistance
          currentY = Math.min(delta * 0.5, MAX_PULL);

          loader.style.transform = `translateY(${currentY}px)`;
          main.style.transform = `translateY(${currentY}px)`; // Pull content too

          // Visual feedback
          if (currentY > 60) {
            loader.classList.add('visible');
            const rotation = (currentY - 60) * 10;
            spinner.style.transform = `scale(1) rotate(${rotation}deg)`;
          } else {
            loader.classList.remove('visible');
            spinner.style.transform = `scale(${currentY / 60})`;
          }

          // Prevent default scrolling if we are pulling specifically
          if (e.cancelable && delta > 10) {
            e.preventDefault();
          }
        } else {
          // Restore if scrolling back up
          resetPosition();
        }
      }, { passive: false });

      document.body.addEventListener('touchend', async () => {
        if (!isPulling || isRefreshing) return;

        isPulling = false;
        loader.style.transition = 'transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28)';
        main.style.transition = 'transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28)';

        if (currentY >= THRESHOLD) {
          // Trigger Refresh
          isRefreshing = true;
          currentY = 60; // Snap to loading position

          loader.style.transform = `translateY(${currentY}px)`;
          main.style.transform = `translateY(${currentY}px)`;
          spinner.classList.add('spinning');

          // Haptic feedback if available
          if (navigator.vibrate) navigator.vibrate(50);

          try {
            await initDashboard(); // Reuse existing refresh logic
            ToastManager.success('Updated');
          } catch (err) {
            ToastManager.error('Update failed');
          } finally {
            setTimeout(() => {
              isRefreshing = false;
              spinner.classList.remove('spinning');
              resetPosition();
            }, 500); // Min delay suitable for UX
          }

        } else {
          resetPosition();
        }
      });

      function resetPosition() {
        currentY = 0;
        loader.style.transform = '';
        main.style.transform = '';
        setTimeout(() => {
          loader.style.transition = '';
          main.style.transition = '';
        }, 300);
      }
    }

    // History Chart Functions
    let chartData = [];
    let chartCanvas = null;
    let chartCtx = null;

    let currentPeriodDays = 7;
    // chartData is reused

    async function updateHistoryChart(days) {
      currentPeriodDays = days;

      // Update active buttons
      document.querySelectorAll('.period-btn, .timeframe-btn').forEach(btn => {
        btn.classList.remove('active');
      });

      document.querySelectorAll('.period-btn').forEach(btn => {
        if (parseInt(btn.dataset.days) === days) btn.classList.add('active');
      });

      document.querySelectorAll('.timeframe-btn').forEach(btn => {
        const btnText = btn.textContent;
        const btnDays = {
          '24H': 1, '1W': 7, '1M': 30, '3M': 90,
          '6M': 180, '1Y': 365, 'ALL': 0
        }[btnText];
        if (btnDays === days) btn.classList.add('active');
      });

      // Show loading
      const historyEmpty = document.getElementById('historyEmpty');
      const chartStats = document.getElementById('chartStats');

      if (historyEmpty) {
        historyEmpty.innerHTML = '<div class="loading"><span class="loading-dots">Loading</span></div>';
        historyEmpty.style.display = 'block';
      }
      if (chartStats) chartStats.style.display = 'none';

      const apiDays = days === 0 ? 'max' : days;

      try {
        // Fetch performance data (now uses purchase dates automatically!)
        const performance = await HistoricalPriceAPI.calculatePerformance(apiDays);

        // CACHE for Desktop Reset
        if (performance) {
          window.currentViewStats = performance;
        }

        if (!performance || !performance.history || performance.history.length < 2) {
          if (historyEmpty) {
            historyEmpty.innerHTML = `
              <div style="text-align: center; padding: 40px;">
                <div style="font-size: 2rem; margin-bottom: 8px;">üìä</div>
                <div>Not enough data yet</div>
                <div style="font-size: 0.8rem; margin-top: 8px; color: var(--text-muted);">
                  ${performance ? 'Only ' + performance.dataPoints + ' data point(s)' : 'Add purchase dates to your assets in the Manage page!'}
                </div>
              </div>
            `;
            historyEmpty.style.display = 'block';
          }
          return;
        }

        if (historyEmpty) historyEmpty.style.display = 'none';
        if (chartStats) chartStats.style.display = 'flex';

        chartData = performance.history;

        // Update data quality badge
        const dataBadge = document.getElementById('chartDataBadge');
        if (dataBadge) {
          dataBadge.style.display = 'inline-block';

          if (performance.incomplete) {
            dataBadge.className = 'chart-data-badge estimated';
            dataBadge.textContent = '‚ö† Partial Data';
            dataBadge.title = 'Some assets failed to load due to API limits';
          } else if (performance.isAccurate) {
            dataBadge.className = 'chart-data-badge real';
            dataBadge.textContent = '‚úì Accurate';
            dataBadge.title = 'Based on your actual purchase dates';
          } else if (performance.isHypothetical) {
            dataBadge.className = 'chart-data-badge estimated';
            dataBadge.textContent = '‚ö† Estimated';
            dataBadge.title = 'Add purchase dates for accurate tracking';
          } else {
            dataBadge.className = 'chart-data-badge real';
            dataBadge.textContent = '‚úì Real Data';
            dataBadge.title = 'Daily snapshot history';
          }
        }

        // Update stats
        document.getElementById('statHigh').textContent = PortfolioApp.formatCurrencyCompact(performance.high);
        document.getElementById('statLow').textContent = PortfolioApp.formatCurrencyCompact(performance.low);
        document.getElementById('statAvg').textContent = PortfolioApp.formatCurrencyCompact(performance.avg);

        const isPositive = performance.change >= 0;
        const statChangeEl = document.getElementById('statChange');
        statChangeEl.textContent = `${isPositive ? '+' : ''}${performance.changePercent.toFixed(1)}%`;
        statChangeEl.style.color = isPositive ? 'var(--profit-text)' : 'var(--loss-text)';

        // Update performance header
        const perfChange = document.getElementById('perfChange');
        const perfChangeIcon = document.getElementById('perfChangeIcon');
        const perfChangeValue = document.getElementById('perfChangeValue');

        if (perfChange) {
          perfChange.className = `performance-change ${isPositive ? 'positive' : 'negative'}`;
          perfChangeIcon.textContent = isPositive ? '‚Üë' : '‚Üì';
          perfChangeValue.textContent = `${isPositive ? '+' : ''}${performance.changePercent.toFixed(1)}%`;
        }

        // Update Mobile Hero PnL (Dynamic based on timeframe)
        const heroPnlBadge = document.getElementById('heroPnlBadge');
        const heroPnlAmount = document.getElementById('heroPnlAmount');
        const heroPnlPercent = document.getElementById('heroPnlPercent');

        if (heroPnlBadge && heroPnlAmount && heroPnlPercent) {
          const sign = isPositive ? '+' : '';
          heroPnlBadge.className = `mobile-pnl-badge ${isPositive ? 'positive' : 'negative'}`;
          heroPnlPercent.textContent = `${isPositive ? '‚Üë' : '‚Üì'} ${sign}${performance.changePercent.toFixed(1)}%`;
          // Show "24H", "7D" etc badge next to amount to verify context? No, just amount is fine per design.
          heroPnlAmount.textContent = `${sign}${PortfolioApp.formatCurrency(performance.change)}`;
          heroPnlAmount.className = `mobile-pnl-amount ${isPositive ? 'positive' : 'negative'}`;
        }

        // Draw charts
        drawEnhancedLineChart(performance.history, 'historyChart');
        drawMiniChart(performance.history, 'heroMiniChart');

      } catch (error) {
        console.error('Error loading historical data:', error);
        if (historyEmpty) {
          historyEmpty.innerHTML = `
            <div style="text-align: center; padding: 40px;">
              <div style="font-size: 2rem; margin-bottom: 8px;">‚ö†Ô∏è</div>
              <div>Failed to load data</div>
              <div style="font-size: 0.8rem; margin-top: 4px;">${error.message}</div>
            </div>
          `;
          historyEmpty.style.display = 'block';
        }
      }
    }


    function drawEnhancedLineChart(data, canvasId) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;

      // Prevent drawing on hidden/zero-sized canvas (Fixes IndexSizeError)
      if (canvas.clientWidth === 0 || canvas.clientHeight === 0) return;

      chartCanvas = canvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      chartCtx = ctx;
      const rect = canvas.parentElement.getBoundingClientRect();

      // High DPI support
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const height = rect.height;
      const padding = { top: 20, right: 15, bottom: 25, left: 15 };

      const values = data.map(d => d.total);
      const minVal = Math.min(...values) * 0.995;
      const maxVal = Math.max(...values) * 1.005;

      ctx.clearRect(0, 0, width, height);

      // Draw grid lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = padding.top + (i / 4) * (height - padding.top - padding.bottom);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      // Calculate points
      const points = data.map((d, i) => ({
        x: padding.left + (i / (data.length - 1)) * (width - padding.left - padding.right),
        y: padding.top + (1 - (d.total - minVal) / (maxVal - minVal)) * (height - padding.top - padding.bottom),
        data: d
      }));

      // Draw gradient fill
      ctx.beginPath();
      ctx.moveTo(points[0].x, height - padding.bottom);
      points.forEach(p => ctx.lineTo(p.x, p.y));
      ctx.lineTo(points[points.length - 1].x, height - padding.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
      // Use a generic gradient fill that matches the line (Violet base)
      gradient.addColorStop(0, 'rgba(138, 43, 226, 0.15)'); // Violet low opacity
      gradient.addColorStop(1, 'rgba(138, 43, 226, 0)');

      ctx.fillStyle = gradient;
      ctx.fill();

      // Draw line
      // Create Line Gradient (Salmon to Violet)
      const lineGradient = ctx.createLinearGradient(0, 0, width, 0);
      lineGradient.addColorStop(0, '#ff9a9e'); // Salmon
      lineGradient.addColorStop(1, '#8a2be2'); // Violet

      ctx.beginPath();
      // Use the gradient for the line
      ctx.strokeStyle = lineGradient;
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      points.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();

      // Store points for tooltip
      canvas._chartPoints = points;

      // Save the clean state (chart only, no crosshair)
      canvas._baseImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas._ctx = ctx; // Store context for reuse

      // Add mouse interaction
      canvas.onmousemove = (e) => handleChartHover(e, canvas, points);
      canvas.onmouseleave = () => hideChartTooltip(canvas);

      // Touch interaction
      canvas.ontouchstart = (e) => {
        // Only prevent default if touching the chart area (allows scrolling elsewhere)
        if (e.target === canvas) e.preventDefault();
      };

      canvas.ontouchmove = (e) => {
        if (e.target === canvas) e.preventDefault();
        const touch = e.touches[0];
        handleChartHover({ clientX: touch.clientX, clientY: touch.clientY }, canvas, points);
      };

      canvas.ontouchend = () => hideChartTooltip(canvas);
    }

    function handleChartHover(e, canvas, points) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const ctx = canvas._ctx;

      // Find closest point
      let closest = points[0];
      let minDist = Math.abs(x - points[0].x);

      points.forEach(p => {
        const dist = Math.abs(x - p.x);
        if (dist < minDist) {
          minDist = dist;
          closest = p;
        }
      });

      // Restore base image (clears previous crosshair)
      if (canvas._baseImage) {
        ctx.putImageData(canvas._baseImage, 0, 0);
      }

      // Draw Crosshair (Vertical Line)
      ctx.beginPath();
      ctx.moveTo(closest.x, 20); // padding.top
      ctx.lineTo(closest.x, canvas.height / window.devicePixelRatio - 25); // height - padding.bottom
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]); // Dashed line
      ctx.stroke();
      ctx.setLineDash([]); // Reset dash

      // Draw Active Point (Outer Glow)
      ctx.beginPath();
      ctx.arc(closest.x, closest.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(138, 43, 226, 0.2)';
      ctx.fill();

      // Draw Active Point (Inner Circle)
      ctx.beginPath();
      ctx.arc(closest.x, closest.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.strokeStyle = '#8a2be2';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.stroke();

      // Mobile Handling: Update Hero Stats instead of Tooltip
      if (canvas.id === 'heroMiniChart') {
        const startData = points[0].data;
        updateHeroStats(closest.data, startData);
      } else if (canvas.id === 'historyChart') {
        const startData = points[0].data;
        updateDesktopStats(closest.data, startData);
        // Also show tooltip for precision
        showChartTooltip(e.clientX, e.clientY, closest, canvas);
      } else {
        showChartTooltip(e.clientX, e.clientY, closest, canvas);
      }
    }

    // New function to update hero stats on mobile scrub
    function updateHeroStats(data, baseData) {
      const balanceEl = document.getElementById('heroTotalValue');
      const pnlContainer = document.getElementById('heroPnlContainer');
      const dateEl = document.getElementById('heroScrubDate');
      const pnlAmountEl = document.getElementById('heroPnlAmount');
      const pnlPercentEl = document.getElementById('heroPnlPercent');

      if (balanceEl) balanceEl.textContent = PortfolioApp.formatCurrency(data.total);

      // Calculate PnL relative to the start of the chart (timeframe)
      let change = 0;
      let percent = 0;

      if (baseData && baseData.total > 0) {
        change = data.total - baseData.total;
        percent = (change / baseData.total) * 100;
      }

      const isPositive = change >= 0;
      const sign = isPositive ? '+' : '';
      const color = isPositive ? 'var(--success)' : 'var(--danger)';

      if (pnlAmountEl) {
        pnlAmountEl.textContent = `${sign}${PortfolioApp.formatCurrency(change)}`;
        pnlAmountEl.style.color = color;
        pnlAmountEl.style.display = '';
      }

      if (pnlPercentEl) {
        pnlPercentEl.textContent = `(${sign}${percent.toFixed(2)}%)`;
        pnlPercentEl.style.color = color;
        pnlPercentEl.style.display = '';
      }

      // Show PnL container
      if (pnlContainer) pnlContainer.style.display = 'flex';

      // Show Date
      if (dateEl) {
        const date = new Date(data.date);
        dateEl.textContent = date.toLocaleDateString('en-US', {
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit'
        });
        dateEl.style.display = 'block';
      }
    }

    // Reset Mobile Stats
    function resetHeroStats() {
      const balanceEl = document.getElementById('heroTotalValue');
      const pnlContainer = document.getElementById('heroPnlContainer');
      const dateEl = document.getElementById('heroScrubDate');
      const pnlAmountEl = document.getElementById('heroPnlAmount');
      const pnlPercentEl = document.getElementById('heroPnlPercent');
      const pnlBadge = document.getElementById('heroPnlBadge');

      if (dateEl) dateEl.style.display = 'none';

      // Restore from window.currentViewStats which matches the active chart view
      if (window.currentViewStats) {
        if (balanceEl) balanceEl.textContent = PortfolioApp.formatCurrency(window.currentViewStats.newest);

        const isPositive = window.currentViewStats.change >= 0;
        const sign = isPositive ? '+' : '';
        const color = isPositive ? 'var(--success)' : 'var(--danger)';
        // Note: CSS vars might not be defined in inline style, use class or explicit color
        // Actually .positive/.negative classes handle color in CSS

        if (pnlBadge) pnlBadge.className = `mobile-pnl-badge ${isPositive ? 'positive' : 'negative'}`;

        if (pnlAmountEl) {
          pnlAmountEl.textContent = `${sign}${PortfolioApp.formatCurrency(window.currentViewStats.change)}`;
          pnlAmountEl.className = `mobile-pnl-amount ${isPositive ? 'positive' : 'negative'}`;
          // Remove manual color to let class handle it
          pnlAmountEl.style.color = '';
        }

        if (pnlPercentEl) {
          pnlPercentEl.textContent = `${isPositive ? '‚Üë' : '‚Üì'} ${sign}${window.currentViewStats.changePercent.toFixed(1)}%`;
          pnlPercentEl.style.color = '';
        }
      }
    }

    // Update Desktop Stats on Hover
    function updateDesktopStats(data, baseData) {
      const valueEl = document.getElementById('perfCurrentValue');
      const changeEl = document.getElementById('perfChange');
      const changeValueEl = document.getElementById('perfChangeValue');
      const changeIconEl = document.getElementById('perfChangeIcon');
      const badgeEl = document.getElementById('chartDataBadge');
      const dateEl = document.getElementById('perfScrubDate'); // Added date element

      if (valueEl) valueEl.textContent = PortfolioApp.formatCurrency(data.total);

      // Hide accuracy badge while scrubbing
      if (badgeEl) badgeEl.style.opacity = '0.5';

      // Update Date
      if (dateEl) {
        const date = new Date(data.date || data.timestamp);
        dateEl.textContent = date.toLocaleDateString('en-US', {
          weekday: 'short',
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit'
        });
        dateEl.style.display = 'block';
      }

      // Calculate Change relative to start of chart
      let change = 0;
      let percent = 0;
      if (baseData && baseData.total > 0) {
        change = data.total - baseData.total;
        percent = (change / baseData.total) * 100;
      }

      const isPositive = change >= 0;
      if (changeEl) {
        changeEl.className = `performance-change ${isPositive ? 'positive' : 'negative'}`;
      }
      if (changeValueEl) {
        changeValueEl.textContent = `${isPositive ? '+' : ''}${percent.toFixed(2)}%`;
      }
      if (changeIconEl) {
        changeIconEl.textContent = isPositive ? '‚Üë' : '‚Üì';
      }
    }

    // Reset Desktop Stats on Mouse Leave
    function resetDesktopStats() {
      const valueEl = document.getElementById('perfCurrentValue');
      const changeEl = document.getElementById('perfChange');
      const changeValueEl = document.getElementById('perfChangeValue');
      const changeIconEl = document.getElementById('perfChangeIcon');
      const badgeEl = document.getElementById('chartDataBadge');
      const dateEl = document.getElementById('perfScrubDate');

      if (badgeEl) badgeEl.style.opacity = '1';
      if (dateEl) dateEl.style.display = 'none';

      if (window.lastPortfolioData) {
        const { grandTotal, totalProfitLossPercent } = window.lastPortfolioData;

        // Wait, window.lastPortfolioData only has current total and All-Time PnL?
        // Actually, updateHistoryChart sets these values based on the *selected timeframe*.
        // We should store the "active timeframe stats" somewhere to reset to.
        // Or re-calculate?
        // Let's store the current displayed stats in data attributes before hovering?
        // No, simplest is to re-trigger a UI update from the active button context, 
        // OR better: cache the "current view stats" in a global object when updateHistoryChart finishes.
      }

      // Fallback: If we have lastPortfolioData, we can at least show current balance.
      // But PnL needs to match the selected button (e.g. 24H change, not All Time).

      // Let's try to parse the "active" button's intent or use a cached "currentStats" object.
      // For now, let's look at updateHistoryChart again to see where it gets the data.
      // It uses HistoricalPriceAPI.calculateStats(days).

      // Strategy: When updateHistoryChart runs, save the result to window.currentViewStats.
      if (window.currentViewStats) {
        if (valueEl) valueEl.textContent = PortfolioApp.formatCurrency(window.currentViewStats.newest);

        const isPositive = window.currentViewStats.change >= 0;
        if (changeEl) changeEl.className = `performance-change ${isPositive ? 'positive' : 'negative'}`;
        if (changeValueEl) changeValueEl.textContent = `${isPositive ? '+' : ''}${window.currentViewStats.changePercent.toFixed(2)}%`;
        if (changeIconEl) changeIconEl.textContent = isPositive ? '‚Üë' : '‚Üì';
      }
    }



    function showChartTooltip(mouseX, mouseY, point, canvas) {
      const tooltip = document.getElementById('chartTooltipFloating');
      if (!tooltip) return;

      const dateEl = tooltip.querySelector('.chart-tooltip-date');
      const valueEl = tooltip.querySelector('.chart-tooltip-value');

      const date = new Date(point.data.date);
      dateEl.textContent = date.toLocaleDateString('en-US', {
        month: 'short', day: 'numeric', year: 'numeric'
      });
      valueEl.textContent = PortfolioApp.formatCurrency(point.data.total);

      // Position tooltip
      const rect = canvas.parentElement.getBoundingClientRect();

      // Calculate position relative to viewport, but anchored to point
      let left = rect.left + point.x;
      let top = rect.top + point.y - 50;

      // Ensure tooltip doesn't go off screen
      const tooltipRect = tooltip.getBoundingClientRect();

      // Horizontal bounds
      if (left - tooltipRect.width / 2 < 10) left = 10 + tooltipRect.width / 2;
      if (left + tooltipRect.width / 2 > window.innerWidth - 10) left = window.innerWidth - 10 - tooltipRect.width / 2;

      // Vertical bounds (if too high, show below point)
      if (top < 10) top = rect.top + point.y + 20;

      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
      tooltip.style.transform = 'translate(-50%, 0)'; // Center horizontally
      tooltip.classList.add('visible');
    }

    function hideChartTooltip(canvas) {
      const tooltip = document.getElementById('chartTooltipFloating');
      if (tooltip) tooltip.classList.remove('visible');

      // Reset Hero Stats (Mobile)
      if (canvas && canvas.id === 'heroMiniChart') {
        resetHeroStats();
      }

      // Reset Desktop Stats
      if (canvas && canvas.id === 'historyChart') {
        resetDesktopStats();
      }

      // Restore clean chart
      if (canvas && canvas._baseImage && canvas._ctx) {
        // ... (rest of function)
        canvas._ctx.putImageData(canvas._baseImage, 0, 0);
      }
    }

    function resetHeroStats() {
      const balanceEl = document.getElementById('heroTotalValue');
      const pnlContainer = document.getElementById('heroPnlContainer');
      const dateEl = document.getElementById('heroScrubDate');
      const pnlAmountEl = document.getElementById('heroPnlAmount');
      const pnlPercentEl = document.getElementById('heroPnlPercent');

      // 1. Restore Visibility
      if (dateEl) dateEl.style.display = 'none';

      if (pnlContainer) {
        pnlContainer.style.display = 'flex';
        // Ensure children are visible if they were hidden individually
        if (pnlAmountEl) pnlAmountEl.style.display = '';
        if (pnlPercentEl) pnlPercentEl.style.display = '';
      }

      // 2. Restore Balance from cached valid data
      if (window.lastPortfolioData && balanceEl) {
        balanceEl.textContent = PortfolioApp.formatCurrency(window.lastPortfolioData.grandTotal);
      } else if (balanceEl && balanceEl.textContent === '$0.00') {
        // Fallback only if we really have nothing
      }

      // Note: We do NOT need to recalculate PnL because updateHeroStats logic 
      // only hides the container; it does not modify the text values inside it.
      // So simply showing the container restores the previous state immediately.
    }


    function drawMiniChart(data, canvasId) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;

      // Preventdrawing on hidden/zero-sized canvas
      if (canvas.clientWidth === 0 || canvas.clientHeight === 0) return;

      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const rect = canvas.parentElement.getBoundingClientRect();

      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const height = rect.height;
      const padding = { top: 5, right: 5, bottom: 5, left: 5 };

      const values = data.map(d => d.total);
      let minVal = Math.min(...values) * 0.99;
      let maxVal = Math.max(...values) * 1.01;

      // Handle flat line case (prevent division by zero)
      if (maxVal === minVal) {
        maxVal = minVal + 1; // Arbitrary range
        if (minVal === 0) {
          maxVal = 1; // Handle all zeros
        }
      }

      ctx.clearRect(0, 0, width, height);

      const isPositive = values[values.length - 1] >= values[0];

      // Draw line
      const lineGradient = ctx.createLinearGradient(0, 0, width, 0);
      lineGradient.addColorStop(0, '#ff9a9e'); // Salmon
      lineGradient.addColorStop(1, '#8a2be2'); // Violet

      ctx.beginPath();
      ctx.strokeStyle = lineGradient;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const points = []; // Store points for interaction

      data.forEach((d, i) => {
        const x = padding.left + (i / (data.length - 1)) * (width - padding.left - padding.right);
        const y = padding.top + (1 - (d.total - minVal) / (maxVal - minVal)) * (height - padding.top - padding.bottom);

        points.push({ x, y, data: d }); // Save point

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Add gradient fill
      const lastX = padding.left + (1) * (width - padding.left - padding.right);
      ctx.lineTo(lastX, height - padding.bottom);
      ctx.lineTo(padding.left, height - padding.bottom);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      // Neutral Violet Fill
      gradient.addColorStop(0, 'rgba(138, 43, 226, 0.1)');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.fill();

      // INTERACTION SETUP
      canvas._chartPoints = points;
      canvas._baseImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas._ctx = ctx;

      // Mouse interaction
      canvas.onmousemove = (e) => handleChartHover(e, canvas, points);
      canvas.onmouseleave = () => hideChartTooltip(canvas);

      // Touch interaction
      canvas.ontouchstart = (e) => {
        if (e.target === canvas) e.preventDefault();
      };

      canvas.ontouchmove = (e) => {
        if (e.target === canvas) e.preventDefault();
        const touch = e.touches[0];
        handleChartHover({ clientX: touch.clientX, clientY: touch.clientY }, canvas, points);
      };

      canvas.ontouchend = () => {
        if (typeof resetHeroStats === 'function') {
          resetHeroStats();
        }
      };
    }

    // Offline Detection
    window.addEventListener('online', () => ToastManager.success('Back online!'));
    window.addEventListener('offline', () => ToastManager.warning('You are offline'));

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize managers
      ThemeManager.init();
      CurrencyManager.init();

      // Update theme icons
      const theme = ThemeManager.get();
      document.getElementById('themeIcon').textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
      const mobileThemeBtn = document.getElementById('mobileThemeBtn');
      if (mobileThemeBtn) mobileThemeBtn.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';

      // Set currency selector
      document.getElementById('currencySelect').value = CurrencyManager.current;

      initMobileMode();
      initTabSystem();
      initBottomNav();
      initDashboard();
      initPullToRefresh(); // Initialize Pull to Refresh

      // Initialize history chart
      updateHistoryChart(7);

      // Handle resize for line charts
      // Handle resize for line charts
      window.addEventListener('resize', () => {
        if (chartData && chartData.length > 0) {
          drawEnhancedLineChart(chartData, 'historyChart');
          drawMiniChart(chartData, 'heroMiniChart');
        }
      });

      // Register Service Worker (only on http/https)
      if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || window.location.protocol === 'http:')) {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('SW registered'))
          .catch(err => console.log('SW registration failed', err));
      }
    });
  </script>
</body>

</html>